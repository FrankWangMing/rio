{"version":3,"file":"nodes.js","sourceRoot":"","sources":["../../src/interfaces/nodes.ts"],"names":[],"mappings":"AAyGA,MAAM,CAAN,IAAY,gBAIX;AAJD,WAAY,gBAAgB;IAC1B,qDAAG,CAAA;IACH,mDAAE,CAAA;IACF,qDAAG,CAAA;AACL,CAAC,EAJW,gBAAgB,KAAhB,gBAAgB,QAI3B","sourcesContent":["import { QueryCallbacksFor } from '@rioe/utils';\r\nimport React from 'react';\r\n\r\nimport { QueryMethods } from '../editor/query';\r\n\r\nexport type UserComponentConfig<T> = {\r\n  displayName: string;\r\n  rules: Partial<NodeRules>;\r\n  related: Partial<NodeRelated>;\r\n  props: Partial<T>;\r\n  custom: Record<string, any>;\r\n  info: Record<string, any>;\r\n  isCanvas: boolean;\r\n\r\n  // TODO: Deprecate\r\n  name: string;\r\n  defaultProps: Partial<T>;\r\n};\r\n\r\nexport type UserComponent<T = any> = React.ComponentType<T> & {\r\n  craft?: Partial<UserComponentConfig<T>>;\r\n};\r\n\r\nexport type NodeId = string;\r\nexport type NodeEventTypes = 'selected' | 'dragged' | 'hovered';\r\n\r\nexport type Node = {\r\n  id: NodeId;\r\n  data: NodeData;\r\n  info: Record<string, any>;\r\n  events: Record<NodeEventTypes, boolean>;\r\n  dom: HTMLElement | null;\r\n  related: Record<string, React.ElementType>;\r\n  rules: NodeRules;\r\n  _hydrationTimestamp: number;\r\n};\r\n\r\nexport type NodeHelpersType = QueryCallbacksFor<typeof QueryMethods>['node'];\r\nexport type NodeRules = {\r\n  canDrag(node: Node, helpers: NodeHelpersType): boolean;\r\n  canDrop(dropTarget: Node, self: Node, helpers: NodeHelpersType): boolean;\r\n  canMoveIn(canMoveIn: Node[], self: Node, helpers: NodeHelpersType): boolean;\r\n  canMoveOut(canMoveOut: Node[], self: Node, helpers: NodeHelpersType): boolean;\r\n};\r\nexport type NodeRelated = Record<string, React.ElementType>;\r\n\r\nexport type NodeData = {\r\n  props: Record<string, any>;\r\n  type: string | React.ElementType;\r\n  name: string;\r\n  displayName: string;\r\n  isCanvas: boolean;\r\n  parent: NodeId | null;\r\n  linkedNodes: Record<string, NodeId>;\r\n  nodes: NodeId[];\r\n  hidden: boolean;\r\n  custom?: any;\r\n  _childCanvas?: Record<string, NodeId>; // TODO: Deprecate in favour of linkedNodes\r\n};\r\n\r\nexport type FreshNode = {\r\n  id?: NodeId;\r\n  data: Partial<NodeData> & Required<Pick<NodeData, 'type'>>;\r\n};\r\n\r\nexport type ReduceCompType =\r\n  | string\r\n  | {\r\n      resolvedName: string;\r\n    };\r\n\r\nexport type ReducedComp = {\r\n  type: ReduceCompType;\r\n  isCanvas: boolean;\r\n  props: any;\r\n};\r\n\r\nexport type SerializedNode = Omit<\r\n  NodeData,\r\n  'type' | 'subtype' | 'name' | 'event'\r\n> &\r\n  ReducedComp;\r\n\r\nexport type SerializedNodes = Record<NodeId, SerializedNode>;\r\n\r\n// TODO: Deprecate in favor of SerializedNode\r\nexport type SerializedNodeData = SerializedNode;\r\n\r\nexport type Nodes = Record<NodeId, Node>;\r\n\r\n/**\r\n * A NodeTree is an internal data structure for CRUD operations that involve\r\n * more than a single node.\r\n *\r\n * For example, when we drop a component we use a tree because we\r\n * need to drop more than a single component.\r\n */\r\nexport interface NodeTree {\r\n  rootNodeId: NodeId;\r\n  nodes: Nodes;\r\n}\r\n\r\ntype NodeIdSelector = NodeId | NodeId[];\r\ntype NodeObjSelector = Node | Node[];\r\n\r\nexport enum NodeSelectorType {\r\n  Any,\r\n  Id,\r\n  Obj,\r\n}\r\n\r\nexport type NodeSelector<\r\n  T extends NodeSelectorType = NodeSelectorType.Any\r\n> = T extends NodeSelectorType.Id\r\n  ? NodeIdSelector\r\n  : T extends NodeSelectorType.Obj\r\n  ? NodeObjSelector\r\n  : NodeIdSelector | NodeObjSelector;\r\n\r\nexport type NodeSelectorWrapper = {\r\n  node: Node;\r\n  exists: boolean;\r\n};\r\n"]}