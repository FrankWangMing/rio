{"version":3,"file":"Positioner.js","sourceRoot":"","sources":["../../src/events/Positioner.ts"],"names":[],"mappings":"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","sourcesContent":["import { getDOMInfo, ROOT_NODE } from '@rio/utils';\r\n\r\nimport findPosition from './findPosition';\r\n\r\nimport { EditorStore } from '../editor/store';\r\nimport {\r\n  DragTarget,\r\n  DropPosition,\r\n  Indicator,\r\n  Node,\r\n  NodeId,\r\n  NodeInfo,\r\n  NodeSelectorWrapper,\r\n} from '../interfaces';\r\nimport { getNodesFromSelector } from '../utils/getNodesFromSelector';\r\n\r\n// Hack: to trigger dragend event immediate\r\n// Otherwise we would have to wait until the native animation is completed before we can actually drop an block\r\nconst documentDragoverEventHandler = (e: DragEvent) => {\r\n  e.preventDefault();\r\n};\r\n\r\n/**\r\n * Positioner is responsible for computing the drop Indicator during a sequence of drag-n-drop events\r\n */\r\nexport class Positioner {\r\n  static BORDER_OFFSET = 10;\r\n\r\n  // Current Node being hovered on\r\n  private currentDropTargetId: NodeId | null;\r\n  // Current closest Canvas Node relative to the currentDropTarget\r\n  private currentDropTargetCanvasAncestorId: NodeId | null;\r\n\r\n  private currentIndicator: Indicator | null = null;\r\n\r\n  private currentTargetId: NodeId | null;\r\n  private currentTargetChildDimensions: NodeInfo[] | null;\r\n\r\n  private dragError: string | null;\r\n  private draggedNodes: NodeSelectorWrapper[];\r\n\r\n  private onScrollListener: (e: Event) => void;\r\n\r\n  constructor(readonly store: EditorStore, readonly dragTarget: DragTarget) {\r\n    this.currentDropTargetId = null;\r\n    this.currentDropTargetCanvasAncestorId = null;\r\n\r\n    this.currentTargetId = null;\r\n    this.currentTargetChildDimensions = null;\r\n\r\n    this.currentIndicator = null;\r\n\r\n    this.dragError = null;\r\n    this.draggedNodes = this.getDraggedNodes();\r\n\r\n    this.validateDraggedNodes();\r\n\r\n    this.onScrollListener = this.onScroll.bind(this);\r\n    window.addEventListener('scroll', this.onScrollListener, true);\r\n    window.addEventListener('dragover', documentDragoverEventHandler, false);\r\n  }\r\n\r\n  cleanup() {\r\n    window.removeEventListener('scroll', this.onScrollListener, true);\r\n    window.removeEventListener('dragover', documentDragoverEventHandler, false);\r\n  }\r\n\r\n  private onScroll(e: Event) {\r\n    const scrollBody = e.target;\r\n    const rootNode = this.store.query.node(ROOT_NODE).get();\r\n\r\n    // Clear the currentTargetChildDimensions if the user has scrolled\r\n    // Because we will have to recompute new dimensions relative to the new scroll pos\r\n    const shouldClearChildDimensionsCache =\r\n      scrollBody instanceof Element &&\r\n      rootNode &&\r\n      rootNode.dom &&\r\n      scrollBody.contains(rootNode.dom);\r\n\r\n    if (!shouldClearChildDimensionsCache) {\r\n      return;\r\n    }\r\n\r\n    this.currentTargetChildDimensions = null;\r\n  }\r\n\r\n  private getDraggedNodes() {\r\n    if (this.dragTarget.type === 'new') {\r\n      return getNodesFromSelector(\r\n        this.store.query.getNodes(),\r\n        this.dragTarget.tree.nodes[this.dragTarget.tree.rootNodeId]\r\n      );\r\n    }\r\n\r\n    return getNodesFromSelector(\r\n      this.store.query.getNodes(),\r\n      this.dragTarget.nodes\r\n    );\r\n  }\r\n\r\n  // Check if the elements being dragged are allowed to be dragged\r\n  private validateDraggedNodes() {\r\n    // We don't need to check for dragTarget.type = \"new\" because those nodes are not yet in the state (ie: via the .create() connector)\r\n    if (this.dragTarget.type === 'new') {\r\n      return;\r\n    }\r\n\r\n    this.draggedNodes.forEach(({ node, exists }) => {\r\n      if (!exists) {\r\n        return;\r\n      }\r\n\r\n      this.store.query.node(node.id).isDraggable((err) => {\r\n        this.dragError = err;\r\n      });\r\n    });\r\n  }\r\n\r\n  private isNearBorders(\r\n    domInfo: ReturnType<typeof getDOMInfo>,\r\n    x: number,\r\n    y: number\r\n  ) {\r\n    const { top, bottom, left, right } = domInfo;\r\n\r\n    if (\r\n      top + Positioner.BORDER_OFFSET > y ||\r\n      bottom - Positioner.BORDER_OFFSET < y ||\r\n      left + Positioner.BORDER_OFFSET > x ||\r\n      right - Positioner.BORDER_OFFSET < x\r\n    ) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private isDiff(newPosition: DropPosition) {\r\n    if (\r\n      this.currentIndicator &&\r\n      this.currentIndicator.placement.parent.id === newPosition.parent.id &&\r\n      this.currentIndicator.placement.index === newPosition.index &&\r\n      this.currentIndicator.placement.where === newPosition.where\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get dimensions of every child Node in the specified parent Node\r\n   */\r\n  private getChildDimensions(newParentNode: Node) {\r\n    // Use previously computed child dimensions if newParentNode is the same as the previous one\r\n    const existingTargetChildDimensions = this.currentTargetChildDimensions;\r\n    if (\r\n      this.currentTargetId === newParentNode.id &&\r\n      existingTargetChildDimensions\r\n    ) {\r\n      return existingTargetChildDimensions;\r\n    }\r\n\r\n    return newParentNode.data.nodes.reduce((result, id: NodeId) => {\r\n      const dom = this.store.query.node(id).get().dom;\r\n\r\n      if (dom) {\r\n        result.push({\r\n          id,\r\n          ...getDOMInfo(dom),\r\n        });\r\n      }\r\n\r\n      return result;\r\n    }, [] as NodeInfo[]);\r\n  }\r\n\r\n  /**\r\n   * Get closest Canvas node relative to the dropTargetId\r\n   * Return dropTargetId if it itself is a Canvas node\r\n   *\r\n   * In most cases it will be the dropTarget itself or its immediate parent.\r\n   * We typically only need to traverse 2 levels or more if the dropTarget is a linked node\r\n   *\r\n   * TODO: We should probably have some special rules to handle linked nodes\r\n   */\r\n  private getCanvasAncestor(dropTargetId: NodeId) {\r\n    // If the dropTargetId is the same as the previous one\r\n    // Return the canvas ancestor node that we found previuously\r\n    if (\r\n      dropTargetId === this.currentDropTargetId &&\r\n      this.currentDropTargetCanvasAncestorId\r\n    ) {\r\n      const node = this.store.query\r\n        .node(this.currentDropTargetCanvasAncestorId)\r\n        .get();\r\n\r\n      if (node) {\r\n        return node;\r\n      }\r\n    }\r\n\r\n    const getCanvas = (nodeId: NodeId): Node => {\r\n      const node = this.store.query.node(nodeId).get();\r\n\r\n      if (node && node.data.isCanvas) {\r\n        return node;\r\n      }\r\n\r\n      if (!node.data.parent) {\r\n        return null;\r\n      }\r\n\r\n      return getCanvas(node.data.parent);\r\n    };\r\n\r\n    return getCanvas(dropTargetId);\r\n  }\r\n\r\n  /**\r\n   * Compute a new Indicator object based on the dropTarget and x,y coords\r\n   * Returns null if theres no change from the previous Indicator\r\n   */\r\n  computeIndicator(dropTargetId: NodeId, x: number, y: number): Indicator {\r\n    let newParentNode = this.getCanvasAncestor(dropTargetId);\r\n\r\n    if (!newParentNode) {\r\n      return;\r\n    }\r\n\r\n    this.currentDropTargetId = dropTargetId;\r\n    this.currentDropTargetCanvasAncestorId = newParentNode.id;\r\n\r\n    // Get parent if we're hovering at the border of the current node\r\n    if (\r\n      newParentNode.data.parent &&\r\n      this.isNearBorders(getDOMInfo(newParentNode.dom), x, y) &&\r\n      // Ignore if linked node because there's won't be an adjacent sibling anyway\r\n      !this.store.query.node(newParentNode.id).isLinkedNode()\r\n    ) {\r\n      newParentNode = this.store.query.node(newParentNode.data.parent).get();\r\n    }\r\n\r\n    if (!newParentNode) {\r\n      return;\r\n    }\r\n\r\n    this.currentTargetChildDimensions = this.getChildDimensions(newParentNode);\r\n    this.currentTargetId = newParentNode.id;\r\n\r\n    const position = findPosition(\r\n      newParentNode,\r\n      this.currentTargetChildDimensions,\r\n      x,\r\n      y\r\n    );\r\n\r\n    // Ignore if the position is similar as the previous one\r\n    if (!this.isDiff(position)) {\r\n      return;\r\n    }\r\n\r\n    let error = this.dragError;\r\n\r\n    // Last thing to check for is if the dragged nodes can be dropped in the target area\r\n    if (!error) {\r\n      this.store.query.node(newParentNode.id).isDroppable(\r\n        this.draggedNodes.map((sourceNode) => sourceNode.node),\r\n        (dropError) => {\r\n          error = dropError;\r\n        }\r\n      );\r\n    }\r\n\r\n    const currentNodeId = newParentNode.data.nodes[position.index];\r\n    const currentNode =\r\n      currentNodeId && this.store.query.node(currentNodeId).get();\r\n\r\n    this.currentIndicator = {\r\n      placement: {\r\n        ...position,\r\n        currentNode,\r\n      },\r\n      error,\r\n    };\r\n\r\n    return this.currentIndicator;\r\n  }\r\n\r\n  getIndicator() {\r\n    return this.currentIndicator;\r\n  }\r\n}\r\n"]}